      SUBROUTINE GBYTE(IN,IOUT,ISKIP,NBYTE)
      CALL GBYTES(IN,IOUT,ISKIP,NBYTE,0,1)
      RETURN
      END
      SUBROUTINE SBYTE(IOUT,IN,ISKIP,NBYTE)
      CALL SBYTES(IOUT,IN,ISKIP,NBYTE,0,1)
      RETURN
      END
      SUBROUTINE GBYTES(BUFIN,BUFOUT,ISKIP,NBITS,NSKIP,N)
C
C     FORTRAN VERSION OF GBYTES FOR CRAY-1
C
      DIMENSION BUFIN(1), BUFOUT(1)
      DATA NBITSW/64/
C     CALL Q8QST4 (7HCRAYLIB, 6HGBYTES, 6HGBYTES, 10HVERSION 01)
C                       NBITS MUST BE .LE. NBITSW
C
      ICON = NBITSW - NBITS
      IF (ICON .LT. 0) RETURN
C
C                       INDEX IS HOW FAR INTO BUFIN TO START
C
      INDEX = ISKIP / NBITSW
C
C                       II IS HOW MANY BITS THE BYTE IS IN FROM THE
C                       LEFT SIDE OF THE WORD.
C
      II = ISKIP - INDEX * NBITSW
C
C                       ISTEP IS THE DISTANCE IN BITS FROM THE START
C                       OF ONE BYTE TO THE NEXT
C
      ISTEP = NBITS+NSKIP
C
C                       IWORDS IS THE DISTANCE IN WORDS
C
      IWORDS = ISTEP / NBITSW
C
C                      IBITS IS HOW MANY BITS TO SKIP AFTER FULL WORD(S)
C
      IBITS = ISTEP - IWORDS * NBITSW
      DO 6 I = 1,N
C
C                       MOVER IS SHIFT COUNT TO RIGHT JUSTIFY BYTE
C
      MOVER = ICON - II
      IF (MOVER .GE. 0) GO TO 4
C
C                       THE BYTE IS SPLIT ACCROSS A WORD BOUNDARY
C
      MOVEL = - MOVER
      BUFOUT(I) = OR( SHIFT( CSMG(0.,BUFIN(INDEX+1),MASK(II  )),MOVEL ),
     A                SHIFT( CSMG(BUFIN(INDEX+2),0.,MASK(MOVEL)),MOVEL))
      GO TO 5
C
C                       THE BYTE IS IN 1 WORD
C
    4 BUFOUT(I) = SHIFTR(CSMG(0.,BUFIN(INDEX+1),SHIFT(MASK(ICON),MOVER))
     A                   , MOVER)
C
C                       INCREMENT II AND INDEX
C
    5 II = II + IBITS
      INDEX = INDEX + IWORDS
      IF (II .LT. NBITSW) GO TO 6
      II = II - NBITSW
      INDEX = INDEX + 1
    6 CONTINUE
C
      RETURN
      END
      SUBROUTINE SBYTES(BUFOUT,BUFIN,ISKIP,NBITS,NSKIP,N)
C
C                       FORTRAN VERSION OF SBYTES FOR CRAY 1
C
CDIR$ INT24 I,IBITS,ICON,INDEX,ISKIP,ISTEP,IWORDS,MOVEL,MOVER,NBITS
CDIR$ INT24 NBITSW,NSKIP,N,II
      DIMENSION BUFIN(1), BUFOUT(2)
      DATA NBITSW /64/
      CALL Q8QST4 (7HCRAYLIB, 6HGBYTES, 6HSBYTES, 10HVERSION 01)
C                       NBITS MUST BE .LE. NBITSW
C
      ICON = NBITSW - NBITS
C
C                       ICON IS NUMBER OF UNALTERED BITS IN A WORD
C
      IF (ICON .LT. 0) RETURN
C
C                       INDEX IS HOW FAR INTO BUFOUT NEXT BYTE IS TO BE
C                       STORED
C
      INDEX = ISKIP / NBITSW
C
C                       II IS HOW MANY BITS THE BYTE IS IN FROM THE
C                       LEFT SIDE OF THE WORD
C
      II = ISKIP - INDEX * NBITSW
C
C                       ISTEP IS THE DISTANCE IN BITS FROM THE START
C                       OF ONE BYTE TO THE NEXT
C
      ISTEP = NBITS + NSKIP
C
C                       IWORDS IS THE DISTANCE IN WORDS
C
      IWORDS = ISTEP / NBITSW
C                      IBITS IS HOW MANY BITS TO SKIP AFTER FULL WORD(S)
C
      IBITS = ISTEP - IWORDS * NBITSW
C
      DO 6 I = 1,N
C
C                       MOVEL IS SHIFT COUNT TO LEFT TO POSITION BYTE
C
      MOVEL = ICON - II
      IF (MOVEL .GE. 0) GO TO 4
C
C                       BYTE CROSSES WORD BOUNDARY
C
      MOVER = - MOVEL
      BUFOUT(INDEX+1) = CSMG( BUFOUT(INDEX+1),SHIFTR(BUFIN(I),MOVER),
     1                                        MASK(II) )
      BUFOUT(INDEX+2) = CSMG( SHIFT(BUFIN(I),NBITSW+MOVEL),BUFOUT(INDEX
     1                        +2),MASK(MOVER) )
C
C                       BYTE CONTAINED IN 1 WORD
C
      GO TO 5
    4 BUFOUT(INDEX+1) = CSMG( BUFOUT(INDEX+1), SHIFT(BUFIN(I),MOVEL),
     1                        SHIFT(MASK(ICON), MOVEL) )
C
C                       INCREMENT II AND INDEX
C
    5 II = II + IBITS
      INDEX = INDEX + IWORDS
      IF (II .LT. NBITSW) GO TO 6
C
C                       CORRECT II LARGER THAN WORD SIZE
C
      II = II - NBITSW
      INDEX = INDEX + 1
    6 CONTINUE
C
      RETURN
      END
